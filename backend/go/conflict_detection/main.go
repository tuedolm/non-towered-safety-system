package main

import (
	"log"
	"math"
	"os"
	"time"
)

// Aircraft represents the state of an aircraft with additional calculated fields
type Aircraft struct {
	Icao24         string    `json:"icao24"`
	Callsign       string    `json:"callsign"`
	Latitude       float64   `json:"latitude"`
	Longitude      float64   `json:"longitude"`
	Altitude       float64   `json:"altitude"`           // feet
	GroundSpeed    float64   `json:"ground_speed"`       // knots
	Heading        float64   `json:"heading"`            // degrees
	VerticalRate   float64   `json:"vertical_rate"`      // feet per minute
	OnGround       bool      `json:"on_ground"`
	LastUpdate     time.Time `json:"last_update"`
	PredictedPath  []Position `json:"predicted_path"`
	AirportVicinity string    `json:"airport_vicinity"`
}

// Position represents a geographic position
type Position struct {
	Latitude  float64 `json:"latitude"`
	Longitude float64 `json:"longitude"`
	Altitude  float64 `json:"altitude"`
	Timestamp time.Time `json:"timestamp"`
}

// Alert represents a safety alert generated by the conflict detection engine
type Alert struct {
	ID           string    `json:"id"`
	AlertType    string    `json:"alert_type"`
	Severity     int       `json:"severity"` // 1-5, with 5 being most severe
	Description  string    `json:"description"`
	Timestamp    time.Time `json:"timestamp"`
	AircraftIcao []string  `json:"aircraft_icao"`
	Location     Position  `json:"location"`
	TimeToImpact float64   `json:"time_to_impact,omitempty"` // seconds
}

// AirportRunway represents a runway at an airport
type AirportRunway struct {
	AirportICAO string  `json:"airport_icao"`
	RunwayID    string  `json:"runway_id"`
	Heading     float64 `json:"heading"`
	Length      float64 `json:"length"` // feet
	Width       float64 `json:"width"`  // feet
	Threshold1  Position `json:"threshold_1"`
	Threshold2  Position `json:"threshold_2"`
}

// Config holds the configuration parameters for the conflict detection engine
type Config struct {
	// Lateral separation minimums (nautical miles)
	PatternSeparation     float64
	ApproachSeparation    float64
	RunwayIncursionRadius float64
	
	// Vertical separation minimums (feet)
	VerticalSeparation     float64
	
	// Time-based parameters (seconds)
	TrajectoryPredictionWindow float64
	StaleDataThreshold        float64
}

// Global state
var (
	activeAircraft = make(map[string]*Aircraft)
	runways = make(map[string][]AirportRunway)
	activeAlerts = make(map[string]*Alert)
	config = Config{
		PatternSeparation:         0.5,  // nm
		ApproachSeparation:        1.0,  // nm
		RunwayIncursionRadius:     0.1,  // nm
		VerticalSeparation:        500,  // feet
		TrajectoryPredictionWindow: 60,  // seconds
		StaleDataThreshold:        30,   // seconds
	}
)

func main() {
	logger := log.New(os.Stdout, "CONFLICT-DETECTION: ", log.LstdFlags)
	logger.Println("Starting conflict detection engine")
	
	// In a production system, we would:
	// 1. Load runway configurations from a database
	// 2. Subscribe to a message queue for aircraft updates
	// 3. Publish alerts to a message queue
	
	// For demonstration, we'll simulate receiving aircraft updates and detecting conflicts
	loadSampleRunways()
	
	// Main processing loop
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()
	
	for range ticker.C {
		// 1. In production, we would receive aircraft updates from a message queue
		// simulateAircraftUpdates()
		
		// 2. Detect conflicts
		detectConflicts(logger)
		
		// 3. Clean up stale data
		removeStaleData()
	}
}

func detectConflicts(logger *log.Logger) {
	// 1. Predict trajectories for all active aircraft
	for _, aircraft := range activeAircraft {
		predictTrajectory(aircraft)
	}
	
	// 2. Check for various types of conflicts
	detectRunwayIncursions(logger)
	detectPatternConflicts(logger)
	detectApproachConflicts(logger)
	
	// Log active alerts
	if len(activeAlerts) > 0 {
		logger.Printf("Active alerts: %d", len(activeAlerts))
		for id, alert := range activeAlerts {
			logger.Printf("Alert %s: %s (Severity: %d)", id, alert.Description, alert.Severity)
		}
	}
}

func predictTrajectory(aircraft *Aircraft) {
	// Skip aircraft on ground or with insufficient data
	if aircraft.OnGround || aircraft.GroundSpeed < 20 {
		return
	}
	
	// Clear previous predictions
	aircraft.PredictedPath = nil
	
	// Calculate speed components
	headingRad := aircraft.Heading * math.Pi / 180.0
	speedNS := aircraft.GroundSpeed * math.Cos(headingRad) // North/South component
	speedEW := aircraft.GroundSpeed * math.Sin(headingRad) // East/West component
	
	// Calculate position changes per second
	// 1 knot = 0.000278 nm/s, 1 degree lat â‰ˆ 60 nm
	latChangePerSecond := speedNS * 0.000278 / 60.0
	lonChangePerSecond := speedEW * 0.000278 / (60.0 * math.Cos(aircraft.Latitude*math.Pi/180.0))
	
	// Predict future positions at 10-second intervals
	for t := 10.0; t <= config.TrajectoryPredictionWindow; t += 10.0 {
		newPos := Position{
			Latitude:  aircraft.Latitude + latChangePerSecond*t,
			Longitude: aircraft.Longitude + lonChangePerSecond*t,
			Altitude:  aircraft.Altitude + (aircraft.VerticalRate/60.0)*t, // convert fpm to fps
			Timestamp: aircraft.LastUpdate.Add(time.Duration(t) * time.Second),
		}
		aircraft.PredictedPath = append(aircraft.PredictedPath, newPos)
	}
}

func detectRunwayIncursions(logger *log.Logger) {
	// For each runway at each airport
	for airportICAO, airportRunways := range runways {
		for _, runway := range airportRunways {
			// Find aircraft near this runway
			aircraftNearRunway := make([]*Aircraft, 0)
			
			for _, aircraft := range activeAircraft {
				if aircraft.AirportVicinity != airportICAO {
					continue
				}
				
				// Check if aircraft is near runway
				dist1 := calculateDistance(aircraft.Latitude, aircraft.Longitude,
					runway.Threshold1.Latitude, runway.Threshold1.Longitude)
				dist2 := calculateDistance(aircraft.Latitude, aircraft.Longitude,
					runway.Threshold2.Latitude, runway.Threshold2.Longitude)
				
				// If aircraft is within incursion radius of either threshold
				if dist1 < config.RunwayIncursionRadius || dist2 < config.RunwayIncursionRadius {
					aircraftNearRunway = append(aircraftNearRunway, aircraft)
				}
			}
			
			// If multiple aircraft near runway, potential conflict
			if len(aircraftNearRunway) > 1 {
				// Check if both aircraft are on the ground or one is landing/taking off
				hasGroundAircraft := false
				hasFlyingAircraft := false
				
				for _, ac := range aircraftNearRunway {
					if ac.OnGround {
						hasGroundAircraft = true
					} else {
						hasFlyingAircraft = true
					}
				}
				
				// If we have both ground and flying aircraft, this is a higher severity
				severity := 3
				if hasGroundAircraft && hasFlyingAircraft {
					severity = 5 // Highest severity
				}
				
				// Create alert
				aircraftIDs := make([]string, 0, len(aircraftNearRunway))
				for _, ac := range aircraftNearRunway {
					aircraftIDs = append(aircraftIDs, ac.Icao24)
				}
				
				alertID := "RI-" + runway.RunwayID + "-" + time.Now().Format("150405")
				alert := Alert{
					ID:           alertID,
					AlertType:    "RUNWAY_INCURSION",
					Severity:     severity,
					Description:  "Multiple aircraft in vicinity of runway " + runway.RunwayID,
					Timestamp:    time.Now(),
					AircraftIcao: aircraftIDs,
					Location: Position{
						Latitude:  (runway.Threshold1.Latitude + runway.Threshold2.Latitude) / 2,
						Longitude: (runway.Threshold1.Longitude + runway.Threshold2.Longitude) / 2,
						Altitude:  0,
					},
				}
				
				// Add to active alerts
				activeAlerts[alertID] = &alert
				logger.Printf("ALERT: Runway incursion detected on runway %s with %d aircraft",
					runway.RunwayID, len(aircraftNearRunway))
			}
		}
	}
}

func detectPatternConflicts(logger *log.Logger) {
	// Group aircraft by airport
	aircraftByAirport := make(map[string][]*Aircraft)
	
	for _, aircraft := range activeAircraft {
		if aircraft.AirportVicinity == "" {
			continue // Skip aircraft not associated with an airport
		}
		
		aircraftByAirport[aircraft.AirportVicinity] = append(
			aircraftByAirport[aircraft.AirportVicinity], aircraft)
	}
	
	// For each airport
	for airportICAO, airportAircraft := range aircraftByAirport {
		// Skip if only one aircraft
		if len(airportAircraft) < 2 {
			continue
		}
		
		// Check each pair of aircraft
		for i := 0; i < len(airportAircraft)-1; i++ {
			for j := i + 1; j < len(airportAircraft); j++ {
				ac1 := airportAircraft[i]
				ac2 := airportAircraft[j]
				
				// Skip ground aircraft
				if ac1.OnGround || ac2.OnGround {
					continue
				}
				
				// Check pattern altitude (typically 800-1000 ft AGL)
				// For demonstration, we assume pattern altitude is between 800 and 1200 ft AGL
				inPattern1 := ac1.Altitude >= 800 && ac1.Altitude <= 1500
				inPattern2 := ac2.Altitude >= 800 && ac2.Altitude <= 1500
				
				// If both in pattern
				if inPattern1 && inPattern2 {
					// Check horizontal separation
					dist := calculateDistance(ac1.Latitude, ac1.Longitude, ac2.Latitude, ac2.Longitude)
					
					// If separation is less than minimum
					if dist < config.PatternSeparation {
						// Create alert
						alertID := "PC-" + ac1.Icao24 + "-" + ac2.Icao24
						alert := Alert{
							ID:           alertID,
							AlertType:    "PATTERN_CONFLICT",
							Severity:     4,
							Description:  "Pattern separation violation between " + ac1.Callsign + " and " + ac2.Callsign,
							Timestamp:    time.Now(),
							AircraftIcao: []string{ac1.Icao24, ac2.Icao24},
							Location: Position{
								Latitude:  (ac1.Latitude + ac2.Latitude) / 2,
								Longitude: (ac1.Longitude + ac2.Longitude) / 2,
								Altitude:  (ac1.Altitude + ac2.Altitude) / 2,
							},
							TimeToImpact: estimateTimeToClosestPoint(ac1, ac2),
						}
						
						// Add to active alerts
						activeAlerts[alertID] = &alert
						logger.Printf("ALERT: Pattern conflict detected between %s and %s (%.1f nm)",
							ac1.Callsign, ac2.Callsign, dist)
					}
				}
			}
		}
	}
}

func detectApproachConflicts(logger *log.Logger) {
	// For each runway at each airport
	for airportICAO, airportRunways := range runways {
		for _, runway := range airportRunways {
			// Find aircraft on approach to this runway
			approachingAircraft := make([]*Aircraft, 0)
			
			for _, aircraft := range activeAircraft {
				if aircraft.AirportVicinity != airportICAO || aircraft.OnGround {
					continue
				}
				
				// Check if aircraft is on final approach
				isOnApproach := isAircraftOnApproach(aircraft, runway)
				
				if isOnApproach {
					approachingAircraft = append(approachingAircraft, aircraft)
				}
			}
			
			// If multiple aircraft on approach to same runway
			if len(approachingAircraft) > 1 {
				// Sort by distance to runway threshold
				// For simplicity, we'll just check pairs
				for i := 0; i < len(approachingAircraft)-1; i++ {
					for j := i + 1; j < len(approachingAircraft); j++ {
						ac1 := approachingAircraft[i]
						ac2 := approachingAircraft[j]
						
						// Check separation
						dist := calculateDistance(ac1.Latitude, ac1.Longitude, ac2.Latitude, ac2.Longitude)
						
						// If separation is less than minimum
						if dist < config.ApproachSeparation {
							// Create alert
							alertID := "AC-" + runway.RunwayID + "-" + ac1.Icao24 + "-" + ac2.Icao24
							alert := Alert{
								ID:           alertID,
								AlertType:    "APPROACH_CONFLICT",
								Severity:     5,
								Description:  "Approach conflict on runway " + runway.RunwayID + " between " + ac1.Callsign + " and " + ac2.Callsign,
								Timestamp:    time.Now(),
								AircraftIcao: []string{ac1.Icao24, ac2.Icao24},
								Location: Position{
									Latitude:  (ac1.Latitude + ac2.Latitude) / 2,
									Longitude: (ac1.Longitude + ac2.Longitude) / 2,
									Altitude:  (ac1.Altitude + ac2.Altitude) / 2,
								},
								TimeToImpact: estimateTimeToClosestPoint(ac1, ac2),
							}
							
							// Add to active alerts
							activeAlerts[alertID] = &alert
							logger.Printf("ALERT: Approach conflict detected on runway %s between %s and %s (%.1f nm)",
								runway.RunwayID, ac1.Callsign, ac2.Callsign, dist)
						}
					}
				}
			}
		}
	}
}

func isAircraftOnApproach(aircraft *Aircraft, runway AirportRunway) bool {
	// Calculate the bearing from runway threshold to the opposite end
	runwayHeading := runway.Heading
	
	// Calculate the bearing from runway threshold to aircraft
	aircraftBearing := calculateBearing(
		runway.Threshold1.Latitude, runway.Threshold1.Longitude,
		aircraft.Latitude, aircraft.Longitude)
	
	// Calculate the difference in bearings
	headingDiff := math.Abs(float64(int(runwayHeading-aircraftBearing+180) % 360 - 180))
	
	// Check if aircraft is aligned with runway (+/- 20 degrees)
	isAligned := headingDiff < 20
	
	// Check if aircraft is descending
	isDescending := aircraft.VerticalRate < -200
	
	// Check if aircraft is within 5nm of runway threshold
	distance := calculateDistance(
		aircraft.Latitude, aircraft.Longitude,
		runway.Threshold1.Latitude, runway.Threshold1.Longitude)
	isWithinRange := distance < 5.0
	
	// Aircraft is on approach if all conditions are met
	return isAligned && isDescending && isWithinRange
}

func estimateTimeToClosestPoint(ac1, ac2 *Aircraft) float64 {
	// Simple estimation assuming constant velocities
	// Convert headings to radians
	heading1Rad := ac1.Heading * math.Pi / 180.0
	heading2Rad := ac2.Heading * math.Pi / 180.0
	
	// Calculate velocity components
	vx1 := ac1.GroundSpeed * math.Sin(heading1Rad)
	vy1 := ac1.GroundSpeed * math.Cos(heading1Rad)
	vx2 := ac2.GroundSpeed * math.Sin(heading2Rad)
	vy2 := ac2.GroundSpeed * math.Cos(heading2Rad)
	
	// Relative velocity
	vx := vx2 - vx1
	vy := vy2 - vy1
	
	// If aircraft are not moving relative to each other
	if math.Abs(vx) < 1 && math.Abs(vy) < 1 {
		return 0
	}
	
	// Convert lat/lon to nm (very approximate)
	// 1 degree latitude â‰ˆ 60 nm
	// 1 degree longitude â‰ˆ 60 * cos(lat) nm
	midLat := (ac1.Latitude + ac2.Latitude) / 2
	lonFactor := math.Cos(midLat * math.Pi / 180.0)
	
	x1 := ac1.Longitude * 60 * lonFactor
	y1 := ac1.Latitude * 60
	x2 := ac2.Longitude * 60 * lonFactor
	y2 := ac2.Latitude * 60
	
	// Current position difference
	dx := x2 - x1
	dy := y2 - y1
	
	// Time to closest point of approach
	t := -(dx*vx + dy*vy) / (vx*vx + vy*vy)
	
	// If time is negative, closest approach is in the past
	if t < 0 {
		return 0
	}
	
	return t
}

func calculateDistance(lat1, lon1, lat2, lon2 float64) float64 {
	// Haversine formula for distance between two points
	// Convert to radians
	lat1Rad := lat1 * math.Pi / 180.0
	lon1Rad := lon1 * math.Pi / 180.0
	lat2Rad := lat2 * math.Pi / 180.0
	lon2Rad := lon2 * math.Pi / 180.0
	
	// Differences
	dLat := lat2Rad - lat1Rad
	dLon := lon2Rad - lon1Rad
	
	// Haversine formula
	a := math.Sin(dLat/2)*math.Sin(dLat/2) +
		math.Cos(lat1Rad)*math.Cos(lat2Rad)*
			math.Sin(dLon/2)*math.Sin(dLon/2)
	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
	
	// Earth radius in nautical miles
	radiusNM := 3440.0
	
	return radiusNM * c
}

func calculateBearing(lat1, lon1, lat2, lon2 float64) float64 {
	// Convert to radians
	lat1Rad := lat1 * math.Pi / 180.0
	lon1Rad := lon1 * math.Pi / 180.0
	lat2Rad := lat2 * math.Pi / 180.0
	lon2Rad := lon2 * math.Pi / 180.0
	
	// Calculate bearing
	y := math.Sin(lon2Rad-lon1Rad) * math.Cos(lat2Rad)
	x := math.Cos(lat1Rad)*math.Sin(lat2Rad) -
		math.Sin(lat1Rad)*math.Cos(lat2Rad)*math.Cos(lon2Rad-lon1Rad)
	
	bearing := math.Atan2(y, x) * 180.0 / math.Pi
	
	// Convert to 0-360 range
	return math.Mod(bearing+360, 360)
}

func removeStaleData() {
	// Remove stale aircraft
	now := time.Now()
	staleThreshold := time.Duration(config.StaleDataThreshold) * time.Second
	
	for id, aircraft := range activeAircraft {
		if now.Sub(aircraft.LastUpdate) > staleThreshold {
			delete(activeAircraft, id)
		}
	}
	
	// Remove resolved alerts
	for id, alert := range activeAlerts {
		// Check if any aircraft in the alert are no longer active
		stillActive := false
		for _, icao := range alert.AircraftIcao {
			if _, exists := activeAircraft[icao]; exists {
				stillActive = true
				break
			}
		}
		
		// If alert is more than 2 minutes old or aircraft are no longer active, remove it
		if !stillActive || now.Sub(alert.Timestamp) > 2*time.Minute {
			delete(activeAlerts, id)
		}
	}
}

func loadSampleRunways() {
	// Add sample runway data for testing
	runways["KRHV"] = []AirportRunway{
		{
			AirportICAO: "KRHV",
			RunwayID:    "13L",
			Heading:     130.0,
			Length:      3100,
			Width:       75,
			Threshold1: Position{
				Latitude:  37.3329,
				Longitude: -121.8195,
			},
			Threshold2: Position{
				Latitude:  37.3280,
				Longitude: -121.8132,
			},
		},
		{
			AirportICAO: "KRHV",
			RunwayID:    "31R",
			Heading:     310.0,
			Length:      3100,
			Width:       75,
			Threshold1: Position{
				Latitude:  37.3280,
				Longitude: -121.8132,
			},
			Threshold2: Position{
				Latitude:  37.3329,
				Longitude: -121.8195,
			},
		},
	}
	
	runways["KPAO"] = []AirportRunway{
		{
			AirportICAO: "KPAO",
			RunwayID:    "13",
			Heading:     134.0,
			Length:      2500,
			Width:       70,
			Threshold1: Position{
				Latitude:  37.4613,
				Longitude: -122.1146,
			},
			Threshold2: Position{
				Latitude:  37.4575,
				Longitude: -122.1098,
			},
		},
		{
			AirportICAO: "KPAO",
			RunwayID:    "31",
			Heading:     314.0,
			Length:      2500,
			Width:       70,
			Threshold1: Position{
				Latitude:  37.4575,
				Longitude: -122.1098,
			},
			Threshold2: Position{
				Latitude:  37.4613,
				Longitude: -122.1146,
			},
		},
	}
} 